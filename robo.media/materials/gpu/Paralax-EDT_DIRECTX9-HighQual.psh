// This file automaticaly generated by MyEngine Shader Generator
// Date/time: 2013/08/25 13:57:42
// DON'T EDIT this file or you may lost your changes!

#define FLOAT float
#define INT   int
#define MAT3  float3x3
#define MAT4  float4x4
#define VEC2  float2
#define VEC3  float3
#define VEC4  float4
#define SAMPLER2D sampler2D
#define TEXTURE2D tex2D
#define VS_IN(vvv) input.vvv
#define VS_OUT(vvv) output.vvv
#define PS_IN(vvv) input.vvv
#define PS_OUT(vvv) output.vvv
#define VARYING
#define UNIFORM uniform
#define MIX lerp

#define M_DIFFUSE(mat)  mat[0].rgba
#define M_AMBIENT(mat)  mat[1].rgba
#define M_SPECULAR(mat) mat[2].rgba
#define M_EMISSIVE(mat) mat[3].rgba

#define L_DIFFUSE(lig)   lig[0].rgba
#define L_AMBIENT(lig)   lig[1].rgba
#define L_SPECULAR(lig)  lig[2].rgba
#define L_POSITION(lig)  lig[3].xyz
#define L_RADIUS(lig)    lig[3].w

#define PARALAX_SCALE 0.03
#define PARALAX_BIAS -PARALAX_SCALE/2.0

#define FOG_START(fog)    fog.x
#define FOG_END(fog)      fog.y
#define FOG_DENSITY(fog)  fog.z

UNIFORM VEC4 uGlobalAmbientColor;
UNIFORM VEC4 uMaterialColors[4];
UNIFORM FLOAT uMaterialShininess;
UNIFORM MAT4 uLighting[4];
UNIFORM SAMPLER2D uTexture0 : register(s0);
UNIFORM SAMPLER2D uTexture3 : register(s3);
UNIFORM VEC3 uFogParams;
UNIFORM VEC3 uFogColor;

struct PS_INPUT
{
VARYING VEC4 TexCoord0 : TEXCOORD0;
VARYING VEC4 TexCoord1 : TEXCOORD1;
VARYING VEC3 EyeVec : TEXCOORD2;
VARYING VEC4 Position : TEXCOORD3;
VARYING VEC4 LightVec0 : TEXCOORD4;
VARYING VEC4 LightVec1 : TEXCOORD5;
VARYING VEC4 LightVec2 : TEXCOORD6;
};

struct PS_OUTPUT
{
    VEC4 FragColor  : COLOR0;
};

PS_OUTPUT main(PS_INPUT input)
{
    PS_OUTPUT output;

    VEC3 position = PS_IN(Position.xyz);
    VEC3 eyeVec = normalize(PS_IN(EyeVec));

    VEC2 tc0 = PS_IN(TexCoord0).xy;
    VEC2 tcnmap = PS_IN(TexCoord1).xy;
    FLOAT height = PARALAX_SCALE * (TEXTURE2D(uTexture3, tcnmap).a) + PARALAX_BIAS;
    // texcoord offset (paralax effect)
    tc0 += VEC2(eyeVec.x,-eyeVec.y) * height;

    VEC4 tcol0 = TEXTURE2D(uTexture0, tc0.xy);

    VEC4 tnmap = TEXTURE2D(uTexture3, tc0.xy);

    VEC4 tcol = VEC4(1.0,1.0,1.0, 1.0);
    tcol *= tcol0;

    VEC3 normal = normalize((tnmap*2.0-1.0).xyz);

    VEC4 mDiffuse = M_DIFFUSE(uMaterialColors);
    VEC4 mAmbient = M_AMBIENT(uMaterialColors);
    VEC4 mSpecular = M_SPECULAR(uMaterialColors);
    VEC4 mEmissive = M_EMISSIVE(uMaterialColors);

    VEC3 specular = VEC3(0.0,0.0,0.0);
    VEC4 color = VEC4(0.0, 0.0, 0.0, mDiffuse.a);
    color.rgb = uGlobalAmbientColor.rgb * mAmbient.rgb + mEmissive.rgb;
    // calculating lighting from Light 0
    {
        VEC4 lDiffuse  = L_DIFFUSE(uLighting[0]);
        VEC4 lAmbient  = L_AMBIENT(uLighting[0]);
        VEC4 lSpecular = L_SPECULAR(uLighting[0]);
        VEC3 lPosition = L_POSITION(uLighting[0]);
        float lRadius  = L_RADIUS(uLighting[0]);
        VEC3 lightVec = normalize(PS_IN(LightVec0).xyz);
        float lDist = length(lPosition - position.xyz);
        float NdotL = max(dot(normal, lightVec), 0.0);
        float idx = min(lDist / lRadius, 1.0);
        float atten = -idx * idx + 1.0;
        color.rgb += atten * (
            NdotL * mDiffuse.rgb * lDiffuse.rgb + // diffuse component
            mAmbient.rgb * lAmbient.rgb // ambient component
            );
        VEC3 reflVec = reflect(-lightVec, normal);
        float specPow = pow(max(dot(eyeVec, reflVec),0.0), uMaterialShininess);
        // separate specular component
        specular += atten * specPow * mSpecular.rgb * lSpecular.rgb;
    }
    // calculating lighting from Light 1
    {
        VEC4 lDiffuse  = L_DIFFUSE(uLighting[1]);
        VEC4 lAmbient  = L_AMBIENT(uLighting[1]);
        VEC4 lSpecular = L_SPECULAR(uLighting[1]);
        VEC3 lPosition = L_POSITION(uLighting[1]);
        float lRadius  = L_RADIUS(uLighting[1]);
        VEC3 lightVec = normalize(PS_IN(LightVec1).xyz);
        float lDist = length(lPosition - position.xyz);
        float NdotL = max(dot(normal, lightVec), 0.0);
        float idx = min(lDist / lRadius, 1.0);
        float atten = -idx * idx + 1.0;
        color.rgb += atten * (
            NdotL * mDiffuse.rgb * lDiffuse.rgb + // diffuse component
            mAmbient.rgb * lAmbient.rgb // ambient component
            );
        VEC3 reflVec = reflect(-lightVec, normal);
        float specPow = pow(max(dot(eyeVec, reflVec),0.0), uMaterialShininess);
        // separate specular component
        specular += atten * specPow * mSpecular.rgb * lSpecular.rgb;
    }
    // calculating lighting from Light 2
    {
        VEC4 lDiffuse  = L_DIFFUSE(uLighting[2]);
        VEC4 lAmbient  = L_AMBIENT(uLighting[2]);
        VEC4 lSpecular = L_SPECULAR(uLighting[2]);
        VEC3 lPosition = L_POSITION(uLighting[2]);
        float lRadius  = L_RADIUS(uLighting[2]);
        VEC3 lightVec = normalize(PS_IN(LightVec2).xyz);
        float lDist = length(lPosition - position.xyz);
        float NdotL = max(dot(normal, lightVec), 0.0);
        float idx = min(lDist / lRadius, 1.0);
        float atten = -idx * idx + 1.0;
        color.rgb += atten * (
            NdotL * mDiffuse.rgb * lDiffuse.rgb + // diffuse component
            mAmbient.rgb * lAmbient.rgb // ambient component
            );
        VEC3 reflVec = reflect(-lightVec, normal);
        float specPow = pow(max(dot(eyeVec, reflVec),0.0), uMaterialShininess);
        // separate specular component
        specular += atten * specPow * mSpecular.rgb * lSpecular.rgb;
    }
    // calculating lighting from Light 3
    {
        VEC4 lDiffuse  = L_DIFFUSE(uLighting[3]);
        VEC4 lAmbient  = L_AMBIENT(uLighting[3]);
        VEC4 lSpecular = L_SPECULAR(uLighting[3]);
        VEC3 lPosition = L_POSITION(uLighting[3]);
        float lRadius  = L_RADIUS(uLighting[3]);
        VEC3 lightVec = normalize(VEC3(PS_IN(LightVec0).w, PS_IN(LightVec1).w, PS_IN(LightVec2).w));
        float lDist = length(lPosition - position.xyz);
        float NdotL = max(dot(normal, lightVec), 0.0);
        float idx = min(lDist / lRadius, 1.0);
        float atten = -idx * idx + 1.0;
        color.rgb += atten * (
            NdotL * mDiffuse.rgb * lDiffuse.rgb + // diffuse component
            mAmbient.rgb * lAmbient.rgb // ambient component
            );
        VEC3 reflVec = reflect(-lightVec, normal);
        float specPow = pow(max(dot(eyeVec, reflVec),0.0), uMaterialShininess);
        // separate specular component
        specular += atten * specPow * mSpecular.rgb * lSpecular.rgb;
    }

    PS_OUT(FragColor) = tcol;
    PS_OUT(FragColor) *= color;
    PS_OUT(FragColor).rgb += specular;

    // fogging
    FLOAT fdepth = PS_IN(Position.z) / PS_IN(Position.w);
    FLOAT fstart = FOG_START(uFogParams);
    FLOAT fend = FOG_END(uFogParams);
    FLOAT fog = clamp((fend - fdepth) / (fend - fstart), 0., 1.);
    PS_OUT(FragColor).rgb = MIX(uFogColor, PS_OUT(FragColor).rgb, fog);
    return output;
}

